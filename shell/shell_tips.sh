# grep 				是行提取命令
# cut   			是列提取命令
# awk				是列提取命令(极其强大的文本分析工具)
# 对比：
# 		awk 以空格为分割域时，是以单个或多个连续的空格为分隔符的；
# 		cut则是以单个空格作为分隔符。
# sed				行处理命令
# 					@quote http://www.cnblogs.com/ggjucheng/archive/2013/01/13/2856901.html
# cat				串连接后传到基本输出

# 要想使shell命令正确执行, 使用$( command ) 相当于`command`命令，返回括号中命令执行的结果

# (cmd1; cmd2; cmd3;)
# 命令组.在括号中的命令列表, 将会作为一个子shell来运行.
# 		 无法读取shell子进程中创建的变量, 有点类似于JS的`闭包`
# 还用于初始化数组
# 
# (())常用于算术运算比较和计算
# $(())返回的结果是括号中表达式值
# @deprecated $[]   $(())的过去形式，现在已经不建议使用
#
# []和[[]]
# [[]]常用于字符串的比较.
# []和[[]]都是条件表达式，不过[[]]有比[]高的容错性
# 
# 
# # 1. 符号$后的括号
# ${a} 变量a的值, 在不引起歧义的情况下可以省略大括号.
# $(cmd) 命令替换, 结果为shell命令cmd的输出, 和`cmd`效果相同, 不过某些Shell版本不支持$()形式的命令替换, 如tcsh.
# $((exp)) 和`expr exp`效果相同, 计算数学表达式exp的数值, 其中exp只要符合C语言的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算.
# 
# 2. 多条命令执行
# (cmd1;cmd2;cmd3) 新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号.
# { cmd1;cmd2;cmd3;} 在当前shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后必须有分号, 第一条命令和左括号之间必须用空格隔开.
# 对{}和()而言, 括号中的重定向符只影响该条命令, 而括号外的重定向符影响到括号中的所有命令.

# 3. 双括号的特殊用法
# (()) 增强括号的用法, 常用于算术运算比较. 双括号中的变量可以不使用$符号前缀, 只要括号中的表达式符合C语言运算规则, 支持多个表达式用逗号分开.
# 比如可以直接使用for((i=0;i<5;i++)), 如果不使用双括号, 则为for i in `seq 0 4`或者for i in {0..4}.
# 再如可以直接使用if (($i<5)), 如果不使用双括号, 则为if [ $i -lt 5 ].
# [[]] 增强方括号用法, 常用于字符串的比较. 主要用于条件测试, 双括号中的表达式可以使用&&, ||, <, >等C语言语法.
# 比如可以直接使用if [[ $a != 1 && $a != 2 ]], 如果不适用双括号, 则为if [ $a -ne 1] && [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ].

# bash set 命令
# set -u 提示错误信息
# set -x 输出log语句
# set -e 脚本只要发生错误, 就终止执行
# set -o pipefail 只要一个子命令失败, 整个管道命令就失败, 脚本就会终止执行
# set -euxo pipefail 放在所有bash脚本的前面 
# 
# set +e 表示关闭-e选项
# command1
# command2
# set -e 表示重新打开-e选项